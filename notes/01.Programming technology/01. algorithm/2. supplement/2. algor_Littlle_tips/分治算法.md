==**整理之前先看懂原理**==



# 1.二分查找(I)




## 1.1题目描述

现在有一个长度为n的有序的序列，m次询问，每次会告诉你一个数字x，让你完成以下两种操作：
1.找到第一个大于等于x的值的下标，如果有多个等于的话找到第一个等于的下标 
2.找到第一个大于x的值的下标
如果没有就输出NO，保证序列有序。



**输入**

第一行两个正整数n(n <= 100000)代表序列长度和m(m <= 100000)代表询问次数，第二行n个数字表示有序序列a(其中0 <= ai <= 200000)。接下来m行每行一个数字x(0 <= x <= 200000)。

输出

答案输出m行，每行两个数字分别表示答案，两个答案之间用空格隔开。

**样例输入** 

```
5 5
1 3 4 5 6
1
2
3
6
7
```

**样例输出** 

```
1 2
2 2
2 3
5 NO
NO NO
```





## 1.2代码示例



```java
package suanfa;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.OutputStream;
import java.io.OutputStreamWriter;
import java.io.PrintWriter;
import java.io.StreamTokenizer;
import java.util.Scanner;
  
public class binarySearch1 {
    static StreamTokenizer in = new StreamTokenizer(new BufferedReader(new InputStreamReader(System.in)));
    
    static PrintWriter out = new PrintWriter(new OutputStreamWriter(System.out));
    
    static int n, k, nums[];
  
    public static void main(String[] args) {
  
        n = nextInt();
        k = nextInt();
        nums = new int[n + 10];
        for (int i = 1; i <= n; i++)
            nums[i] = nextInt();//通过循环将输入的一行n个数据放入同一个数组中
        while (k-- > 0) {
            int x = nextInt();bbb//后序依次输入的m行数
            out.print(binsearch_1(x));  
            out.print(" ");
            out.println(binsearch_2(x));
        }
        out.flush();
  
    }
  //找到大于等于x的数据的下标
  //方法最后的return一行中unms[L]>x与nums[L]>=x是区分两个结果的关键
    static String binsearch_1(int x) {
        int l = 1, r = n;
        while (l < r) {
            int mid = (l + r) >> 1;//将大数组分成了两个小数组分别是[l,mid]与[mid+1,r]
            if (nums[mid] >= x)
                r = mid;
            else
                l = mid + 1;
          //仔细思考一下，最后剩下的一定是，一对数字（如果所求结果存在的话），那么mid = i
          //因为i比x小，所以取l = mid+1,此时l=r,循环结束。
        }
        return l>0&&l<=n&&nums[l] >= x?String.valueOf(l):"NO";
    }
     //找到大于x的数据的下标 
    static String binsearch_2(int x) {
        int l = 1, r = n;
        while (l < r) {
            int mid = (l + r) >> 1;
        if (nums[mid] >= x)
            r = mid;
        else
            l = mid + 1;
    }
        return l>0&&l<=n&&nums[l] > x?String.valueOf(l):"NO";
    }
      
  
    static int nextInt() {
        try {
            in.nextToken();
        } catch (IOException e) {
            // TODO Auto-generated catch block
            e.printStackTrace();
        }
        return (int) in.nval;
    }
  
    static String next() { //不知道这个是干嘛用的
        try {s
            in.nextToken();
        } catch (IOException e) {
            // TODO Auto-generated catch block
            e.printStackTrace();
        }
        return in.sval;
    }
  
}
```

## 1.3补充



### 1.3.1 异常



#### try-catch



```java
try{

}catch (IOException e){

}
```

IOException e：代表捕捉的是输入输出异常。e是对象。

即：如果发生输入输出的异常就会在这里捕捉，catch (IOException e)｛XXX｝中xxx会被执行。



比如你要输入一个int型进行运算，但是你输入了一个其他类型的，这就会出错，Java中用异常来处理这种错误。



#### e.printStackTrace()

```java
catch(Exception e){
    e.printStackTrace() ;
}
```

  

当try语句中出现异常是时，会执行catch中的语句。

Java运行时系统会自动将catch括号中的Exception e 初始化，也就是实例化Exception类型的对象。e是此[对象引用](https://www.baidu.com/s?wd=对象引用&tn=SE_PcZhidaonwhc_ngpagmjz&rsv_dl=gh_pc_zhidao)名称。

然后e（引用）会自动调用Exception类中指定的方法，也就出现了e.printStackTrace() ;。

printStackTrace()方法：

意思是：在命令行打印异常信息在程序中出错的位置及原因。







#### IOException异常的处理方式 

首先看一段代码：

![img](https://img-blog.csdnimg.cn/20191231144906936.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3poYW5zaGl4aWFuZw==,size_16,color_FFFFFF,t_70)

这段代码有明显的IO异常。一般我们的做法是捕获异常。



```java
  public static void main(String[] args) {
       
     
            try {
                // 文件可能不存在
                  FileWriter fw= new FileWriter("W:\\demo.txt");
 
                // 写到一半可能失败
                fw.write("fhuerfjebfj"+LINE_SEPARATOR+"hubjhj");
 
                //底层关闭资源时可能向上抛出异常
                fw.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
 
        }
```



但是如果在文件创建过程中失败，可能需要关闭io流，所以需要finally

```java
import java.util.*;

public class Main {
  public static void main(String[] args) {
    /*
    *流对象处理方式在try的外面创建引用变量
    *在try{}里面进行对象的初始化
        */
    try{
        //查找文件可能出错
        FileWriter fw = FileWriter(fileName: "D://...");
        //写入文件失败
        fw.write(...);
        //底层资源关闭抛出异常
        fw.close();
    }catch(IOException e){
        e.printStackTrace();
        
    }finally{
        f.close;
    }    
  }
}

```



但是这样fw对象的作用域是在finally是无效的。所以就得把fw拿到try{ xxx}外层定义。

close底层可能出现错误。所以又得捕获异常。

![img](https://img-blog.csdnimg.cn/2019123115023998.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3poYW5zaGl4aWFuZw==,size_16,color_FFFFFF,t_70)

直至这样子我们的代码才能通过编译期。

```java
 public static void main(String[] args)  {
            /**
             *  流对象的处理方式是在try的外面创建引用变量
             *  在try{} 里面进行对象的初始化
             */
            FileWriter  fw =null;
            try {
                // 文件可能不存在
                fw = new FileWriter("W:\\demo.txt");
                // 写到一半可能失败
                fw.write("fhuerfjebfj"+LINE_SEPARATOR+"hubjhj");
                //底层关闭资源时可能向上抛出异常
                fw.close();
            } catch (IOException e) {
                e.printStackTrace();
            }finally {
                try {
                    fw.close();
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
 
        }
```

运行却抛出空指针异常：这是因为在创建文件目录时出现了异常，fw为空，还要运行fw.close( )所导致。![img](https://img-blog.csdnimg.cn/2019123115052427.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3poYW5zaGl4aWFuZw==,size_16,color_FFFFFF,t_70)

直至修改如此我们的代码才处理好了IOException异常和空指针异常

```java
  public static void main(String[] args)  {
            /**
             *  流对象的处理方式是在try的外面创建引用变量
             *  在try{} 里面进行对象的初始化
             */
            FileWriter  fw =null;
            try {
                // 文件可能不存在
                fw = new FileWriter("W:\\demo.txt");
                // 写到一半可能失败
                fw.write("fhuerfjebfj"+LINE_SEPARATOR+"hubjhj");
                //底层关闭资源时可能向上抛出异常
                fw.close();
            } catch (IOException e) {
                e.printStackTrace();
            }finally {
                if (fw != null) {
                    try {
                        fw.close();
                    } catch (IOException e) {
                       throw  new RuntimeException("关闭失败.....");
                    }
                }
            }
        }
```



![img](https://img-blog.csdnimg.cn/20191231151034632.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3poYW5zaGl4aWFuZw==,size_16,color_FFFFFF,t_70)







### 1.3.2 三元法



? 和:相当于if和else

```java
例 (a%2==0)?a是偶数:a是奇数
    
if(a%2==0)
{
System.out.print("a是偶数");
}
else
{
System.out.print("a是奇数");
}

```



### 1.3.3 StreamTokenizer



#### java StreamTokenizer使用

**注意：**用JAVA解题一般用Scanner类来进行**输入**，但对时间要求严格的题，用它可能会超时，后者处理**输入**的效率要高点。 
现小结如下： 

1、类java.io.StreamTokenizer可以**获取** **输入** 流并将其分析为Token（标记）。 
StreamTokenizer的nextToken方法读取下一个标记 

2、默认情况下，StreamTokenizer认为下列内容是Token:字母、数字、除c和c++注释符号以外的其他符号。
   如符号“/”不是Token，注释后的内容也不是，而"/"是Token。单引号和双引号以及其总的内容，只能算一个Token。 

3、为了提高效率，**使用**BufferedReader，如下，创建StreamTokenizer对象 

```java
StreamTokenizer st =new StreamTokenizer(new BufferedReader(new InputStreamReader(System.in)));
```

4、为了从流中**获取**标记，可以调用StreamTokenizer的nextToken()方法。 
调用nextToken()方法以后，如果标记是字符串，可用 String s=st.sval,如果是整数用 int n=(int) st.nval得到。 



```java
st.nextToken();     

int i=(int) st.nval;     //st.navl默认解析出的格式是double

st.nextToken();     

int j=(int) st.nval; 

st.nextToken();     

String s=st.sval;
```

关键点：

- - 类java.io.StreamTokenizer可以获取输入流并将其分析为Token(标记)。StreamTokenizer的nextToken方法将读取下一个标记
  - 默认情况下，StreamTokenizer认为下列内容是Token：字母、数字、除C和C++注释符号以外的其他符号。如符号“/”不是Token，注释后的内容也不是，而“\”是Token。单引号和双引号以及其中的内容，只能算是一个Token。
  - 要统计文件的字符数，不能简单地统计Token数，因为字符数不等于Token，按照Token的规定，引号中的内容就算是10页也算是一个Token。如果希望引号和引号中的内容都算作Token，应该通过StreamTokenizer的ordinaryCha()方法将单引号和双引号当做普通字符处理。



```java
//直接在程序中指定了文件输入路径：String fileName = "d:/ceshi.txt";

package szu.edu;

import java.io.BufferedReader;
import java.io.FileReader;
import java.io.IOException;
import java.io.StreamTokenizer;

/**
 * 使用StreamTokenizer来统计文件中的字符数
 * StreamTokenizer 类获取输入流并将其分析为“标记”，允许一次读取一个标记。
 * 分析过程由一个表和许多可以设置为各种状态的标志控制。
 * 该流的标记生成器可以识别标识符、数字、引用的字符串和各种注释样式。
 * 
 *  默认情况下，StreamTokenizer认为下列内容是Token: 字母、数字、除C和C++注释符号以外的其他符号。
 *  如符号"/"不是Token，注释后的内容也不是，而"\"是Token。单引号和双引号以及其中的内容，只能算是一个Token。
 *  统计文章字符数的程序，不是简单的统计Token数就万事大吉，因为字符数不等于Token。按照Token的规定，
 *  引号中的内容就算是10页也算一个Token。如果希望引号和引号中的内容都算作Token，应该调用下面的代码：
 *     st.ordinaryChar('\'');  //将单引号设为普通字符
 * st.ordinaryChar('\"');    //将双引号设为普通字符
 */
public class StatisFileChars {

    /**
     * 统计字符数
     * @param fileName 文件名
     * @return    字符数
     */
    public static long statis(String fileName) {

        FileReader fileReader = null;
        try {
            fileReader = new FileReader(fileName);
            //创建分析给定字符流的标记生成器
            StreamTokenizer st = new StreamTokenizer(new BufferedReader(
                    fileReader));

            //ordinaryChar方法指定字符参数在此标记生成器中是“普通”字符。
            //下面指定单引号、双引号和注释符号是普通字符
            st.ordinaryChar('\'');
            st.ordinaryChar('\"');
            st.ordinaryChar('/');

            String s;
            int numberSum = 0;
            int wordSum = 0;
            int symbolSum = 0;
            int total = 0;
            //nextToken方法读取下一个Token.
            //TT_EOF指示已读到流末尾的常量。
            while (st.nextToken() != StreamTokenizer.TT_EOF) {
                //在调用 nextToken 方法之后，ttype字段将包含刚读取的标记的类型
                switch (st.ttype) {
                //TT_EOL指示已读到行末尾的常量。
                case StreamTokenizer.TT_EOL:
                    break;
                //TT_NUMBER指示已读到一个数字标记的常量
                case StreamTokenizer.TT_NUMBER:
                    //如果当前标记是一个数字，nval字段将包含该数字的值
                    s = String.valueOf((st.nval));
                    System.out.println(s);
                    numberSum += s.length();
                    break;
                //TT_WORD指示已读到一个文字标记的常量
                case StreamTokenizer.TT_WORD:
                    //如果当前标记是一个文字标记，sval字段包含一个给出该文字标记的字符的字符串
                    s = st.sval;
                    wordSum += s.length();
                    break;
                default:
                    //如果以上3中类型都不是，则为英文的标点符号
                    s = String.valueOf((char) st.ttype);
                    symbolSum += s.length();
                }
            }
            System.out.println("sum of number = " + numberSum);
            System.out.println("sum of word = " + wordSum);
            System.out.println("sum of symbol = " + symbolSum);
            total = symbolSum + numberSum + wordSum;
            System.out.println("Total = " + total);
            return total;
        } catch (Exception e) {
            e.printStackTrace();
            return -1;
        } finally {
            if (fileReader != null) {
                try {
                    fileReader.close();
                } catch (IOException e1) {
                }
            }
        }
    }

    public static void main(String[] args) {
        String fileName = "d:/ceshi.txt";
        StatisFileChars.statis(fileName);
    }
}
```



注意：除了以上的用法，还有一个很常见的用法。用于基本的输入操作！(比如：常用语acm编程中，输入效率比较高。)

***BufferedReader\*** provides quite fast read operations for almost all problems. But this class may be used to read single characters and lines only. To read tokens and numbers you should use ***StringTokenizer\*** or***StreamTokenizer\***.



```java
import java.io.*;

public class Main
{
    public static void main(String[] args) throws IOException
    {
        StreamTokenizer in = new StreamTokenizer(new BufferedReader(new InputStreamReader(System.in)));
        //PrintWriter out = new PrintWriter(new OutputStreamWriter(System.out));
        int a, b;
        while(in.nextToken() != StreamTokenizer.TT_EOF)
        {
            a = (int)in.nval;
            in.nextToken();
            b = (int)in.nval;
            //out.println(a + b);
            System.out.println("a + b = "+(a+b));
        }
        //out.flush();
    }
}
```



### 1.34 java快速输入输出 

==***\*java的Scanner 比较慢（出了名的了），\****如果需要输入 105105 数量级的数据并输出同样数量级的数据，使用Scanner和System.out耗时将很可能超过1s。==

#### 1、使用 StreamTokenizer 和 PrintWriter

```java
StreamTokenizer in = new StreamTokenizer(new BufferedReader(new InputStreamReader(System.in)));
PrintWriter out = new PrintWriter(new OutputStreamWriter(System.out));
```

判断文件结尾： 

相当于Java的 while(scanner.hasNext())，或者C的 while(scanf("%d",&n)!=EOF)，在 StreamTokenizer 类中判断文件结尾使用 while (in.nextToken() != StreamTokenizer.TT_EOF) ，StreamTokenizer.TT_EOF这个是个参数，就是相当于EOF了

#### 2、使用 BufferedReader 

```java
BufferedReader input = new BufferedReader(new InputStreamReader(System.in));
```

```java
/**
 * 为了从流中获取标记，可以调用StreamTokenizer的nextToken()方法。
 * 调用nextToken()方法以后
 * 如果标记是字符串，可用 String s=st.sval
 * 如果是整数用 int n=(int) st.nval
 * 如果是浮点数用 int n=st.nval   //st.navl默认解析出的格式是double
 * StreamTokenizer.TT_EOF这是个参数，就是指文件尾，EOF
 */
 
/* 下面这是IO流包装，可以看不懂，直接套用就好*/
StreamTokenizer in = new StreamTokenizer(new BufferedReader(new InputStreamReader(System.in)));
PrintWriter out = new PrintWriter(new OutputStreamWriter(System.out));
 
in.nextToken();//第一个次读取前记得调用  in.nextToken()读下一个标记  nextToken()方法相当于让光标指向下一个位置，记得写
int a = (int) in.nval;/*获取整数*/
out.print(a);
out.flush();//这里如果不刷新，不会输出结果  刷新缓冲区，否则a会留在缓冲区
 
in.nextToken();
double b = in.nval;//st.navl默认解析出的格式是double
out.print(b);
out.flush();
 
in.nextToken();
String str = in.sval; /*注意：sval是获取不带空格的字符串，含有空格的字符串貌似无法读取。*/
out.print(str);/*输出语句*/
out.flush();/*刷新输出缓冲区*/
```

```
// 用于输入的对象
StreamTokenizer in = new StreamTokenizer(new BufferedReader(new InputStreamReader(System.in)));
// 用于输出的对象
PrintWriter out = new PrintWriter(new OutputStreamWriter(System.out));
// 必须先调用这个把下一个数据拉进来
in.nextToken();
int n = (int) in.nval; // 然后调用in.nval即可得到拉进来的数据
//如果不知道还有没有下一个数据，可以这么写
while (in.nextToken() != StreamTokenizer.TT_EOF) {
    // 然后在这里重复上述的输入过程，并干一些别的事情
}
//输出
out.println(n);
out.printf("%d ", n);
//不管用上述的哪一种输出，最后记得flush
out.flush();
```





### 1.3.5 JAVA中的flush()方法



```java
out.flush();
out.close()
```

这在我以前的代码里有所体现，但是只知道这是清空缓冲区的作用，但是不知道具体什么是缓冲区，以及为什么要清空他，所以今天学习了一下，我简单举个例子你们就知道了：

首先，咱们设想要给鱼缸换水，所以需要一个水泵，水泵是连接鱼缸和下水道的，咱们的任务就是将鱼缸里面水全抽干，这时，我们就可以**把水管当做缓冲区**。如果咱们一见鱼缸里面水抽干了就**立马关**了水泵，这时会发现水管里还有来不及通过水泵流向下水道的**残留水**，我们可以把抽水当做读数据，排水当做写数据，水管当做缓冲区，这样就容易明白了。

那么这样一来我们如果**中途调用`close()`方法**，**输出区也还是有数据的**，就像水缸里有水，只是在缓冲区遗留了一部分，这时如果我们**先调用`flush()`方法**，就会**强制把数据输出**，缓存区就清空了，最后再关闭读写流调用close()就完成了。![在这里插入图片描述](https://img-blog.csdnimg.cn/20190212210938254.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4MTI5MDYy,size_16,color_FFFFFF,t_70)

###1.3.6 基本类型互相强制转换方法

#### 1. 由 基本数据型态转换成 String

String 类别中已经提供了==将基本数据型态转换成 String== 的==static== 方法
也就是 String.valueOf() 这个参数多载的方法
有下列几种
String.valueOf(boolean b) : 将 boolean 变量 b 转换成字符串
String.valueOf(char c) : 将 char 变量 c 转换成字符串
String.valueOf(char[] data) : 将 char 数组 data 转换成字符串
String.valueOf(char[] data, int offset, int count) :
将 char 数组 data 中 由 data[offset] 开始取 count 个元素 转换成字符串
String.valueOf(double d) : 将 double 变量 d 转换成字符串
String.valueOf(float f) : 将 float 变量 f 转换成字符串
String.valueOf(int i) : 将 int 变量 i 转换成字符串
String.valueOf(long l) : 将 long 变量 l 转换成字符串
String.valueOf(Object obj) : 将 obj 对象转换成 字符串, 等于 obj.toString()
用法如:
int i = 10;
String str = String.valueOf(i);
这时候 str 就会是 "10"

#### 2. 由 String 转换成 数字的基本数据型态

要将 String 转换成基本数据型态转
大多需要使用基本数据型态的包装类别

比如说 String 转换成 byte
可以使用 Byte.parseByte(String s)
这一类的方法如果无法将 s 分析 则会丢出 NumberFormatException

**byte** :

Byte.parseByte(String s) : 将 s 转换成 byte
Byte.parseByte(String s, int radix) : 以 radix 为基底 将 s 转换为 byte
比如说 Byte.parseByte("11", 16) 会得到 17

**double** :

Double.parseDouble(String s) : 将 s 转换成 double

**float** :

Double.parseFloat(String s) : 将 s 转换成 float

**int** :

Integer.parseInt(String s) : 将 s 转换成 int

**long** :

Long.parseLong(String

















# 2.二分查找(II)

## 2.1题目描述

对于一个长度为n的有序序列有以下两种操作：
1.对于给定的值x，找到大于等于x的值，如果有多个等于x的值那么就找到最后一个值为x的序列下标，否则就找到第一个大于x的序列下标
2.对于给定的值x，找到小于等于x的值，如果有多个等于x的值那么就找到最后一个值为x的序列下标，否则就找到第一个小于x的序列下标
如果找不到就输出"NO", 序列下标从1开始，序列保证有序。

输入

第一行包含两个正整数n(n <= 100000) 和 m(m <= 100000)，分别表示序列大小和询问的次数。第二行是n个由空格隔开的有序序列a(其中0 <= ai <= 200000), 接下来m行每行一个整数x(0 <= x <= 200000)表示要查找的数。

输出

输出包含m行，m行包含两个整数x y, 分别代表第一个和第二个操作的答案，或者找不到就输出"NO"。

样例输入

```
5 5
1 3 3 3 5
1
2
3
5
6
```

样例输出 

```
1 1
2 1
4 4
5 5
NO 5
```



## 2.2代码示例

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.OutputStreamWriter;
import java.io.PrintWriter;
import java.io.StreamTokenizer;

public class binarySearch2 {
    static StreamTokenizer in = new StreamTokenizer(new BufferedReader(new InputStreamReader(System.in)));
    static PrintWriter out = new PrintWriter(new OutputStreamWriter(System.out));
    static int n, k, min = Integer.MAX_VALUE, max = Integer.MIN_VALUE;
    static double[] nums;

​    public static void main(String[] args) {

​        n = nextInt();
​        k = nextInt();
​        nums = new double[n + 10];
​        for (int i = 1; i <= n; i++)
​            nums[i] = nextInt();
​        nums[0] = -1;
​        while (k-- > 0) {
​            double now = nextInt();
​            out.print(bin_min(now + 0.5));
​            out.print(" ");
​            out.println(bin_max(now - 0.5));
​        }
​        out.flush();

​    }

​    static String bin_min(double x) {
​        int l = 0, r = n;
​        while (l < r) {
​            int mid = (l + r + 1) >> 1;
​            if (nums[mid] <= x)
​                l = mid;
​            else
​                r = mid - 1;
​        }

​        if (nums[l] + 0.5 == x)
​            return String.valueOf(l);
​        if (l > n - 1)
​            return "NO";
​        return String.valueOf(l + 1);
​    }

​    static String bin_max(double x) {
​        int l = 1, r = n + 1;
​        while (l < r) {
​            int mid = (l + r) >> 1;
​            if (nums[mid] >= x)
​                r = mid;
​            else
​                l = mid + 1;
​        }
​        if (nums[l] - 0.5 == x) {
​            while ((nums[l] - 0.5 == x))
​                l++;
​        }
​        if (l <= 1 || l > n + 1)
​            return "NO";
​        return String.valueOf(l - 1);
​    }

​    static int nextInt() {
​        try {
​            in.nextToken();
​        } catch (IOException e) {
​            // TODO Auto-generated catch block
​            e.printStackTrace();
​        }
​        return (int) in.nval;
​    }

​    static String next() {
​        try {
​            in.nextToken();
​        } catch (IOException e) {
​            // TODO Auto-generated catch block
​            e.printStackTrace();
​        }
​        return in.sval;
​    }

}





##2.3补充

### Integer.MAX_VALUE|| Integer.MIN_VALUE



```java
 static int min = Integer.MAX_VALUE;
 static int max = Integer.MIN_VALUE;
```



java int 类整数的最大值是 2 的 31 次方 - 1 = **2147483648 - 1** = **2147483647**

java能够用 **Integer.MAX_VALUE** 表示它，即 int value = Integer.MAX_VALUE;

数据库==Integer.MAX_VALUE + 1 = Integer.MIN_VALUE = -2147483648==

再大的数就要用 long （最大值 2 的 63 次方 - 1 ）或者 ...



- 这是Integer类中的一个**int类型的**常量MAX_VALUE
  它**代表int所能表示的最大值 0x7FFFFFFF**
- 相对应的是Integer类中的另一个常量MIN_VALUE
  它代表int所能表示的最小值 0x80000000



### 相关题目

####题干

给定一个包括 n 个整数的数组 nums 和 一个目标值 target。找出 nums 中的三个整数，使得它们的和与 target 最接近。返回这三个数的和。假定每组输入只存在唯一答案。

#### 示例：

输入：nums = [-1,2,1,-4], target = 1
输出：2
解释：与 target 最接近的和是 2 (-1 + 2 + 1 = 2) 。

#### 提示：

3 <= nums.length <= 10^3
-10^3 <= nums[i] <= 10^3
-10^4 <= target <= 10^4

####思路

可以使用暴力解法进行求解，但是时间复杂度很高，容易超出时间限制，这里的思路是比较常见的思路：排序+双指针。
先对数组进行升序排序，然后根据左右指针向中间进行查找：

- 当sum>target时，表示当前和太大，应该将右指针向左移动，因为左边的元素小于右边的元素
- 当sum<target时，说明当前和太小，应该将左指针向右移动
- 当sum==target，直接返回即可

#### java代码

```java
import java.util.Arrays;
public class threeSumClosest {
    public int threeSumClosest(int[] nums, int target) {
        /**
         * 思路：先对数组进行升序排序，然后使用双指针进行查找
         */
        Arrays.sort(nums);
        int n = nums.length;
//        int min = 10000000;
        int min = Integer.MAX_VALUE;//int类型越界
        for (int i = 0; i < n; ++i) {
            //防止重复计算
            if (i > 0 && nums[i] == nums[i - 1])
                continue;
            int l = i + 1, r = n - 1;
            while (l < r) {
                int sum = nums[l] + nums[r] + nums[i];
                if (sum == target)//如果等于target 直接返回即可
                    return target;
                //如果当前的和最靠近target 那么替换之前的和
                if (Math.abs(sum - target) < Math.abs(min - target))
                    min = sum;
                if (sum > target) {//和太大，应该将右指针左移动
                    --r;//方法一
                    //方法二
//                    int r0 = r - 1;
//                    while (l < r0 && nums[r0] == nums[r])
//                        --r0;
//                    r = r0;
                } else //和偏小，应该左指针  向右移动
                {
                    ++l;//方法一
                    //方法二
//                    int l0 = l + 1;
//                    while (l0 < r && nums[l0] == nums[l])
//                        ++l0;
//                    l = l0;
                }
            }
        }
        return min;
    }

    public static void main(String[] args) {
        int[] nums = {-3,-2,-5,3,-4};
        System.out.println(new threeSumClosest().threeSumClosest(nums, -1));
    }
}

```





### Java中&&和&，||和|的区别

java当中的[逻辑运算符](https://so.csdn.net/so/search?q=逻辑运算符&spm=1001.2101.3001.7020)，&&（短路与）和&表示逻辑与，||（短路或）和|表示逻辑或

#### &&和&

&&和&都可以表示[逻辑与](https://so.csdn.net/so/search?q=逻辑与&spm=1001.2101.3001.7020)，但他们是有区别的，共同点是他们两边的条件都成立的时候最终结果才是true；

不同点是&&只要是第一个条件不成立为false，就不会再去判断第二个条件，最终结果直接为false，而&判断的是所有的条件；

##### 测试&&：

```java
package test;
 
public class Test{
	public static void main(String[] args){
		int i = 23;
		int j = 21;
		if ((i == j) && (100 / 0 == 0))
			System.out.println("1");
		else
			System.out.println("没有报错");
	}
}
```

输出的结果为：没有报错

==正常情况下100 / 0 == 0是会报错的，而上面的示例就没有报错，就是因为&&的第一个条件不成立，后面的一个条件被短路了，所以程序没有报错==

##### 测试&：

```java
package com.test;
 
public class Test {
 
	public static void main(String[] args) {
		int i = 23;
		int j = 21;
		if ((i == j) & (100 / 0 == 0))
			System.out.println("1");
		else
			System.out.println("没有报错");
	}
}
```

```java
package com.test;
 
public class Test {
 
	public static void main(String[] args) {
		int i = 23;
		int j = 23;
		if ((i == j) & (100 / 0 == 0))
			System.out.println("1");
		else
			System.out.println("没有报错");
	}
}
```

上面的两段代码的结果都会报错，证明&是判断所有的条件





#### **||和|**

||和|都表示逻辑或，共同点是只要两个判断条件其中有一个成立最终的结果就是true，区别是||只要满足第一个条件，后面的条件就不再判断，而|要对所有的条件进行判断。



##### 测试||：

```java
package com.test;
 
public class Test {
 
	public static void main(String[] args) {
		int i = 23;
		int j = 23;
		if ((i == j) || (100 / 0 == 0))
			System.out.println("1");
		else
			System.out.println("没有报错");
	}
}
```

输出结果为：1

##### 测试|：



```java
package com.test;
 
public class Test {
 
	public static void main(String[] args) {
		int i = 23;
		int j = 23;
		if ((i == j) | (100 / 0 == 0))
			System.out.println("1");
		else
			System.out.println("没有报错");
	}
}
```

程序会报错







### java中的break和continue关键字使用总结



#### 作用和区别

**break的作用**是跳出当前循环块（for、while、do while）或程序块（switch）。

在循环块中的作用是跳出当前正在循环的循环体。

在程序块中的作用是中断和下一个case条件的比较。

**continue用于**结束循环体中其后语句的执行，并跳回循环程序块的开头执行下一次循环。









# 3.快速排序(函数)



## 3.1题目描述



**利用快速排序算法将读入的n个数从小到大排序后输出。**

```
（C++选手请不要试图使用STL，虽然你可以使用sort一遍过，但是你并没有掌握快速排序算法的精髓。）

本题为函数题，只需要提交函数即可
c/c++：
void QuickSort(int a[],int l,int r)
{
  
}
java：
public static void QuickSort(int[] a,int l,int r)
{
  
} 
```



**输入**

```

```

**输出**

```
```



## 3.2代码示例

```java
public static void QuickSort(int[] nums, int l, int r) {
    	if (r - l <= 0)
            return;
        int pri = nums[l], left = l, right = r;
        while (left < right) {
            //先对右半指针部分检查
            while (left < right && nums[right] >= pri)
                right--;
            nums[left] = nums[right];
            //再对左指针部分检查
            while (left < right && nums[left] <= pri)
                left++;
            nums[right] = nums[left];
        }
    
    	// 跳出循环时left和right相等,此时的left或right就是pri的正确索引位置
		// 由原理部分可以很清楚的知道left位置的值并不是pri,所以需要将tmp赋值给arr[left]
    	 nums[left] = pri;
    
        QuickSort(nums, l, left - 1);
        QuickSort(nums, left + 1, r);
    }
```

```java

    public static void quicksort(int[] arr, int left, int right) {
        if (right - left <= 0)
            return;

        System.out.println(123);
 
        int pri = arr[left],l = left, r = right;

        while (l < r) {
            while (l < r && arr[r] >= pri)
                r--;
            arr[l] = arr[r];
            while (l < r && arr[l] < pri)
                l++;
            arr[r] = arr[l];
        }

        arr[l] = pri;


        quicksort(arr, left, l - 1);
        quicksort(arr, l + 1, right);
    }


```



## 3.3补充



### 3.3.1快速排序思想

- 选取数组的第一个元素为基准元素，将剩下的数组分成两部分（目的：将比基准元素小的元素放入左部分，比基准元素大的放入右部分）
- 分别指派一个左指针，一个右指针，
  - 先从右指针指向的元素与基准元素比较，如果比基准元素小则将这个数字放入左部分，
  - 并将左指针右移一位与基准元素进行比较如果比基准元素大组指针向左滑动，
  - 然后将新的元素与基准元素比较
- 比较完成后，左右指针指向同一个位置，且该位置为空，那么将基准元素赋值给左指针。
- 然后再进行分治算法，直到剩下做后一个元素（默认已经排好顺序）



### 3.3.2while()后的{} 与 ；

while循环后面有==**{}**==，循环会执行==**{}**==里面的内容

while循环后面没有==**{}**==但是有==**；**==，循环会执行第一个==**；**==之前的内容

#### 例如

```java
 while (left < right && nums[right] >= pri)
                right--;				//满足条件会执行第一个;前的代码 此处right--;
            nums[left] = nums[right];	//不满足循环条件会跳过循环，执行nums[left] = nums[right];
```

















# 4.归并排序(函数)



## 4.1题目描述

**利用归并排序算法将读入的n个数从小到大排序后输出。** 

```
（C++选手请不要试图使用STL，虽然你可以使用sort一遍过，但是你并没有掌握快速排序算法的精髓。） 

本题为函数题，只需要提交函数即可 
c/c++： 
void MergeSort(int[] a,int l,int r)
{ 
  
} 
java： 
public static void MergeSort(int[] a,int l,int r) 
{ 
  
} 


```





## 4.2代码示例

```java
public static void MergeSort(int[] a, int l, int r) {
        if (r >= l) return; //如果r=l说明此时只有一个元素，单个元素认为是有序，所以return。
    	//如果r>l,shu
    	//当遍历到最后一个元素时，从底层向上回溯，从底层向上回溯
    	//第一次是回溯到前两个元素，形成有序数组a1
    	//然后前两个元素之后的两个元素,形成有序数组a2
    	//先左后右//先左后右
    	

        int mid = (l + r) >> 1, left = l, right = mid + 1, o = 0;
    	//mid是左数组的有边界
    	//right是右数组的左边界
    	//o是中转数组temp[]的起始位置
    
    	//每个数字分为一组
        MergeSort(a, l, mid);
        MergeSort(a, mid + 1, r);
    
        int temp[] = new int[r - l + 1];
    	//中转数组
    	//left <= mid表示左数组没有遍历完，right<=r同理
   
        while (left <= mid && right <= r) {
            if (a[left] <= a[right])
                temp[o++] = a[left++];
            else
                temp[o++] = a[right++];
        }
    	//经过上面循环，左右中有一个数组已经全部放入temp[]
    	//下面两个循环是为了将为遍历完成的某一个数组放入temp[]
        while(left<=mid) temp[o++] = a[left++];
        while(right<=r) temp[o++] = a[right++];
    
    `	//将已经遍历好的大数组覆盖掉原来相同位置但并未排好序的数组
         for(int i:temp) 
            a[l++] =i;//这一部a[l++]使用的很巧妙
    }
```

![6B525413D7A2A3B61D747E2E5278C277](D:\桌面文件\录屏\6B525413D7A2A3B61D747E2E5278C277.png)



## 4.3补充



### 归并排序思想

1.  将序列中带排序数字分为若干组，每个数字分为一组

   > (默认长度为1的序列是有序的)

2. 将若干个组**两两合并**，保证合并后的组是有序的

3. **重复第二步操作**直到只剩下一组，排序完成





### 本地代码debug

```java
import java.io.*;
public class Main{

    public static void  main (String[] args) {

		int[] list = {9,7,8,6,3,1,2,4,5};
        int l = 0;
        int r = list.length-1;

        guibing g = new guibing();
        
        g.MergeSort(list,l,r);
        
        for (int i: list) {
            System.out.println(i);
        }
        
    }
}

```

输出结果

```java
public class guibing {

    public static void MergeSort(int[] a, int l, int r) {
        if (r - l <= 0)
            return;

        int mid = (l + r) >> 1, left = l, right = mid + 1, o = 0;
        //每个数字分为一组
        MergeSort(a, l, mid);
        MergeSort(a, mid + 1, r);

        int temp[] = new int[r - l + 1];
        
        //下面三行是为了深入理解代码，输出结果图在后面
        System.out.print(r-l+"  ");
        System.out.print(r);
        System.out.println(l);

        while (left <= mid && right <= r) {
            if (a[left] <= a[right])
                temp[o++] = a[left++];
            else
                temp[o++] = a[right++];
        }
        while(left<=mid) temp[o++] = a[left++];
        while(right<=r) temp[o++] = a[right++];
        for(int i:temp)
            a[l++] =i;
    }
}


```

**tmid,right结果测试用结果**

![image-20220509225222361](C:\Users\16660\AppData\Roaming\Typora\typora-user-images\image-20220509225222361.png)

### 增强for循环

```java
int[] num = {1,2,3,4,5,6};
for(int i: num){
    System.out.print(i);
}
```







# 5.堆排序

## 5.1题目描述

n个数建立小根堆后，输出每次移至堆顶的元素。
为保证答案相匹配，有如下规定
1、初始建堆过程从n/2开始向上调整
2、堆调整时，如果左右儿子都小于父亲，则调整权值最小的。
3、堆调整时若左右儿子相等，优先调整左儿子。



输入

第一行一个正整数n。(1<=n<=5e3) 
第二行n个整数 数据保证在int范围内 

输出

输出n-1个数即每次操作的堆尾元素

样例输入 

```
5
2 3 5 1 4 
```

样例输出 

```
4 4 5 5 
```

### 提示

样例解释![img](http://172.23.79.51/upload/pimg1238_1.jpg)![img](http://172.23.79.51/upload/pimg1238_2.jpg)以此类推

## 5.2代码示例

~~~java
import java.io.*;
import java.util.ArrayList;
import java.util.List;
 
public class Main {
    
    static StreamTokenizer in = new StreamTokenizer(new BufferedReader(new InputStreamReader(System.in)));
    static PrintWriter out = new PrintWriter(new OutputStreamWriter(System.out));
    static int n, T, mod = 1000000007;
    static List<Integer> nums = new ArrayList<>(5500);
 
    public static void main(String[] args) {
       
        n = nextInt();
        nums.add(0);//堆排序存储元素的第一个序号从1开始，所以此处用0填充第一个元素
        
        for (int i = 1; i <= n; i++)
            nums.add(nextInt());
        
        Houp houp = new Houp(nums, n);
        
        while (n-- > 1) {
            out.print(houp.pop());
            out.print(" ");
        }
        out.flush();
    }
 
    static int gcd(int x, int y) {
        return y == 0 ? x : gcd(y, x % y);
    }
 
    static int nextInt() {
        try {
            in.nextToken();
        } catch (IOException e) {
            // TODO Auto-generated catch block
            e.printStackTrace();
        }
        return (int) in.nval;
    }
 
    //try catch
    static String next() {
        try {
            in.nextToken();
        } catch (IOException e) {
            // TODO Auto-generated catch block
            e.printStackTrace();
        }
        return in.sval;
    }
 
}
 
class Houp {
    int size;
    List<Integer> tree;
 
    public Houp(List<Integer> tree, int size) {
        super();
        this.tree = tree;
        this.size = size;
        for (int i = size >> 1; i > 0; i--)
            down(i); 
        //使用down函数，算是从中间元素，即有子节点的元素开始排序，遍历完成后数组以大顶堆的模式排好顺序
    }
 
    final int pop() {
        tree.set(1, tree.get(size--));
        //将倒数第二个元素放在指定排序数组的第一个位置，相当于取代了第一个元素，同时取代元素不变
        down(1);
        //将第一个元素采用down函数下沉
        return tree.get(size + 1);
    }
 		
    
    void insert(int val) {
        tree.add(val); 
        ++size;
        //x--和--x的区别：1、【--x】是x的值先自减1，再计算x的值；2、【x--】是先计算x的值，再将x的值自减1。
        up(size);
    }
 
    final void swap(int x, int y) {
        int temp = tree.get(x);
        tree.set(x, tree.get(y));
        tree.set(y, temp);
    }
 
    public void up(int x) {
        for (; x != 1; x >>= 1) {
            //第一个分号前的内容是提供数据，第二个是循环条件，第三个是对数据的操作
            if (tree.get(x>>1) <= tree.get(x))
                break;
            swap(x, x >> 1);
        }
    }
    

    
    public void down(int x) {
        int son = x;
        if ((x << 1) <= size && tree.get(x<<1) < tree.get(son))
            son = x << 1;
        if ((x << 1 | 1) <= size && tree.get(x<<1|1) < tree.get(son))
            son = x << 1 | 1;
        if (son != x) {
            swap(x, son);
            down(son);
        }
    }	
    //c语言程序中x>>=1，如果作用于整数x，就是把x右移一位，把x的二进制值的最后一位丢弃，最高位补0。
	//实际就是把x的值除以2。在运算结果上等价于x=x/2
}

~~~



### 堆排序思想(图解)



![image-20220406223153353](https://cnchu-1310638968.cos.ap-nanjing.myqcloud.com//%E5%8D%9A%E5%AE%A2/image-20220406223153353.png)



![image-20220406223324436](https://cnchu-1310638968.cos.ap-nanjing.myqcloud.com//%E5%8D%9A%E5%AE%A2/image-20220406223324436.png)

![image-20220406223358114](https://cnchu-1310638968.cos.ap-nanjing.myqcloud.com//%E5%8D%9A%E5%AE%A2/image-20220406223358114.png)



![image-20220406223525885](https://cnchu-1310638968.cos.ap-nanjing.myqcloud.com//%E5%8D%9A%E5%AE%A2/image-20220406223525885.png)



![QQ截图20220406233106](C:\Users\16660\Desktop\QQ截图20220406233106.png)

![QQ截图20220406233111](C:\Users\16660\Desktop\QQ截图20220406233111.png)

1 9 3 8 7 6 5 2 4 0, ==按照如下的方式建立堆，貌似确实可以将最大的元素放在数组头部，但是原因？==

![image-20220406234601889](https://cnchu-1310638968.cos.ap-nanjing.myqcloud.com//%E5%8D%9A%E5%AE%A2/image-20220406234601889.png)

==排序时每一次排序都会将最大的元素放在数组头部，然后再将其与最后面的数组交换随着i减1，最大值与堆断开联系，然后新的堆再进行新的排序。==



**并不是在内存中建立真正的二分结构调整，而是通过数组元素与元素之间的下标关系来完成的**

**所以数组的初始状态就代表了堆的初始状态，不需要使用代码进行转换**



![image-20220407204944919](https://cnchu-1310638968.cos.ap-nanjing.myqcloud.com//%E5%8D%9A%E5%AE%A2/image-20220407204944919.png)

![image-20220407205222990](https://cnchu-1310638968.cos.ap-nanjing.myqcloud.com//%E5%8D%9A%E5%AE%A2/image-20220407205222990.png)







![image-20220407210234499](https://cnchu-1310638968.cos.ap-nanjing.myqcloud.com//%E5%8D%9A%E5%AE%A2/image-20220407210234499.png)





![image-20220407210643610](https://cnchu-1310638968.cos.ap-nanjing.myqcloud.com//%E5%8D%9A%E5%AE%A2/image-20220407210643610.png)

**利用了表达式自动类型提升**





## 5.3补充



### 1、java的数据类型

![image-20220407212606412](https://cnchu-1310638968.cos.ap-nanjing.myqcloud.com//%E5%8D%9A%E5%AE%A2/image-20220407212606412.png)

第九种数据类型void(空的)

在void的原码中是将函数设置为private，所以对于void 外部是不能new对象，因此不能再堆中分配空间储存对应的值

![image-20220407213006769](https://cnchu-1310638968.cos.ap-nanjing.myqcloud.com//%E5%8D%9A%E5%AE%A2/image-20220407213006769.png)



### 2、super

#### 含义

在java中super表示调用父类（基类）的函数：
如果super()表示调用父类的构造函数，
super.method表示调用父类中的函数(非构造函数)

你这里是调用java.awt.Frame的构造函数。



在Java中，this通常指当前对象，super则指父类的。当你想要引用当前对象的某种东西，比如当前对象的某个方法，或当前对象的某个成员，你便可以利用this来实现这个目的，当然，this的另一个用途是调用当前对象的另一个构造函数，这些马上就要讨论。如果你想引用父类的某种东西，则非super莫属。

#### 代码示例(super)

```java
/**
 * @ author: X3vvv
 * @ date: 13/11/2020
 */
class Son extends Father {
	// 私有变量hobby
	private String hobby;
	// 构造器
    public Son(String name, String hobby) {
    	super(name);
    	this.hobby = hobby;
    }
}
public class Father {
	// 私有变量name
    private String name;
    // 构造器
    public Father(String name) { this.name = name; }
   
	// 用于测试的主函数
	public static void main(String[] args) {} // 暂时为空
}

```



我们对Son实例化，创建一个Son的对象：

```java
	// 用于测试的主函数
	public static void main(String[] args) {
		Son monkey = new Son("WuKong");
	}

```

#### 代码示例(super拓展)

**子类中使用父类的私有变量**

我们给Father类添加两个方法*speak()\*和*getName()*，给Son类添加*speak()*方法：

```java
/**
 * @ author: X3vvv
 * @ date: 13/11/2020
 */
class Son extends Father {
	// 私有变量hobby
	private String hobby;
	// 构造器
    public Son(String name, String hobby) {
    	super(name);
    	this.hobby = hobby;
    }
    // speak()方法
    public void speak() {
    	// 调用了从父类继承的函数，以使用属于父类的私有变量name
        System.out.println("^&*#$*.." + this.getName() + "..$%*&");
    }
}

public class Father {
	// 私有变量name
    private String name;
    // 构造器
    public Father(String name) { this.name = name; }
    // getName()方法
    protected String getName() { return name; }
    // speak()方法
    public void speak() {
        System.out.println("You can call me father, or " + name);
    }
    
	// 用于测试的主函数
	public static void main(String[] args) {
        Father human = new Father("Xavier");
        Son monkey = new Son("Jack", ""); // hobby只是为了方便说明，故为空值
        human.speak(); 		// 输出结果："You can call me father, or Xavier"
        monkey.speak(); 	// 输出结果："^&*#$*..Jack..$%*&"
    }
}

```

通过测试可以发现，尽管只有父类拥有变量name，且因为name是私有变量，子类没法在类的内部使用它。

但是，通过使用Son构造器中的super()，初始化父类里的name。然后再利用父类里的public方法——getName()，最终monkey成功的使用了父类里的私有变量name！
因此，**得益于构造器中的super()，即使是父类中的私有变量，子类也能够使用。**



### 3、--x与x--区别

 **1、【--x】是x的值先自减1，再计算x的值；**

**2、【x--】是先计算x的值，再将x的值自减1。**



### 4、程序中x>>1与x<<1

```
1、c语言程序中x>>=1，如果作用于整数x，就是把x右移一位，把x的二进制值的最后一位丢弃，最高位补0。
实际就是把x的值除以2。在运算结果上等价于x=x/2
```

```
x>>1：将x右移一位，等价于/2

x<<1：将x左移一位，等价于*2
```







# 6.逆序数



## 6.1题目描述

A为一个有n个数字的有序集 (1<=n<=1e5)，其中所有数字各不相同。
当存在正整数 i, j 使得 1 ≤ i < j ≤ n 而且 A[i] > A[j]，则 <A[i], A[j]> 这个有序对称为 A 的一个逆序对，也称作逆序数。
请问序列A中的逆序对有多少个。

输入

第一行，序列长度n。（1<=n<=1e5）
第二行，序列a[1]...a[n]。（a[i]<1e8）

输出

逆序对个数。

样例输入

```
5
5 4 3 2 1
```

样例输出 

```
10
```





## 6.2代码示例



```java
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.OutputStreamWriter;
import java.io.PrintWriter;
import java.io.StreamTokenizer;
 
public class Main {
    static StreamTokenizer in = new StreamTokenizer(new BufferedReader(new InputStreamReader(System.in)));
    static PrintWriter out = new PrintWriter(new OutputStreamWriter(System.out));
    static int n, k, min = Integer.MAX_VALUE, max = Integer.MIN_VALUE, nums[];
    static long res = 0;
 
    public static void main(String[] args) {
        int n = nextInt();
        nums = new int[n + 1];
        for (int i = 1; i <= n; i++)
            nums[i] = nextInt();
        MergeSort(nums, 1, n);
        System.out.println(res);
    }
 
    public static void MergeSort(int[] a, int l, int r) {
        if (r - l <= 0)
            return;
        int mid = (l + r) >> 1, left = l, right = mid + 1, o = 0;
        MergeSort(a, l, mid);
        MergeSort(a, mid + 1, r);
        int temp[] = new int[r - l + 1];
        while (left <= mid && right <= r) {
            if (a[left] <= a[right])
                temp[o++] = a[left++];
            else {
                temp[o++] = a[right++];
                res += mid - left + 1;
            }
        }
        while (left <= mid)
            temp[o++] = a[left++];
        while (right <= r)
            temp[o++] = a[right++];
        for (int i : temp)
            a[l++] = i;
    }
 
    static void seap(int x, int y) {
        int t = nums[x];
        nums[x] = nums[y];
        nums[y] = t;
    }
 
    static int nextInt() {
        try {
            in.nextToken();
        } catch (IOException e) {
            // TODO Auto-generated catch block
            e.printStackTrace();
        }
        return (int) in.nval;
    }
 
    static String next() {
        try {
            in.nextToken();
        } catch (IOException e) {
            // TODO Auto-generated catch block
            e.printStackTrace();
        }
        return in.sval;
    }
 
}
```

相当于在==归并排序的基础==上，再加一个判断



## 6.3补充



### 逆序数(例题)

#### 题目描述

在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组.求出这个数组中的逆序对的总数P。并将P对1000000007取模的结果输出。即输出P%1000000007

#### 输入描述:

题目保证输入的数组中没有的相同的数字

数据范围:
				对于%50的数据，size<=10^4^

​				对于%75的数据，size<=10^5

​				==对于%100的数据，size<=2*10^5==



```java
public class Main {
	private long sum;//用来去统计逆序对的个数
    public int InversePairs(int []array){
		sum = 0;
		int 1 = 0;
		int r = array.length - 1;
        divide(l ,r, array);
		return (int) (sum % 1000008007);
    }
    
	private void divide(int l,int r, int[] array){
		if (1 !=r){
		int mid =(l +r)>>1;
        divide(1, mid,array);
		divide( l: mid + 1，r, array);
        merge(l,r, mid，array);
	}
}

    
    private void merge(int l, int r, int mid， int[] array){
		int i = l;			//左区间的起点
		int j = mid + 1;	//右区间的起点
        
        int[] temp = new int[r - l + 1];//用于接收元素的空数组
        int index = 0;
        
		while (i<= mid &8 j< r){
			if (array[i] >array[i]){
				temp[index++] = array[i++];
				
                sum += mid - i+l; //因为前面的元素已经排好序，所以由mid-i+1可以求出左数组比arr[j]多的个数
                //这一行是核心，去统计逆序对个数，统计的基础是在归并排序的合并过程中，合并的两个子序列都是有序的
			}else {
				temp[index++] = array[i++];
			}
		}
        
		while(i <= mid){
			temp[index++] = array[i++];
		}
		while (i <=r){
			temp[ index++] = array[i++];
		}

}
```



### 为什么大数操作要对1000000007取模?

**在刷Leetcode的过程中遇到多次大数操作需要1000000007取模，防止大数越界**

**大数越界：** 随着 nn 增大, f(n)f(n) 会超过 Int32 甚至 Int64 的取值范围，导致最终的返回值错误

```

```



就很好奇去搜索了一下原因，搜到最多的答案如下：



为什么要对1000000007取模大数阶乘，大数的排列组合等，一般都要求将输出结果对1000000007取模 为什么总是1000000007呢
 = =大概≖‿≖✧是因为：（我猜的，不服你打我呀~）

**1.**1000000007是一个质数

**2.**int32位的最大值为2147483647，所以对于int32位来说1000000007足够大

**3.**int64位的最大值为2^63-1，对于1000000007来说它的平方不会在int64中溢出 所以在大数相乘的时候，因为(a∗b)%c=((a%c)∗(b%c))%c，所以相乘时两边都对1000000007取模，再保存在int64里面不会溢出



但是对于上述答案，还不能够完全的解答我的疑惑

1. 1000000007是一个质数
    `质数有很多个，选择这个的理由呢？`
2. int32位的最大值为2147483647，所以对于int32位来说1000000007足够大
    `在1000000007到2147483647之间还有很多比它要更大的数，足够大并不少最大，并不能说明它的唯一性`
3. int64位的最大值为2^63-1，对于1000000007来说它的平方不会在int64中溢出 所以在大数相乘的时候，因为(a∗b)%c=((a%c)∗(b%c))%c，所以相乘时两边都对1000000007取模，再保存在int64里面不会溢出
    `在1000000007到2^62-1之间的数都不会溢出，为何偏偏要选1000000007呢？`



**部分回答**

关于为什么选择1000000007，除了你列举的原因，我觉得还有一个很重要的原因：

1000000007最简单，也意味着最好记。
1000000001虽然简单，但它不是质数，因为它可以被另一个数整除7.
1000000003 也不是质数，因为它可以被另一个数整除23.





#7.种树家



## 7.1题目描述

N棵树,初始树高全为0,每次可以花费b[i]的体力使第i颗树长高a[i]米
问体力为M时，所有树高度的最小值最大是多少(保证答案不超过1e9)

输入

第一行n,m(1<=n<=1000,1<=m<=1e6),表示n颗树,体力为m
接下来2行，
第一行a[i],1<=a[i]<=10
第二行b[i],1<=b[i]<=10

输出

所有树高度的最小值最大是多少

样例输入

```
3 3
1 1 1
1 1 1
```

样例输出 

```
1
```





## 7.2代码示例

```java
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.OutputStreamWriter;
import java.io.PrintWriter;
import java.io.StreamTokenizer;
 
public class Main {
    static StreamTokenizer in = new StreamTokenizer(new BufferedReader(new InputStreamReader(System.in)));
    static PrintWriter out = new PrintWriter(new OutputStreamWriter(System.out));
    static int n, m, k, a[], b[], min = Integer.MAX_VALUE, max = Integer.MIN_VALUE, nums[];
 
    public static void main(String[] args) {
        n = nextInt();
        m = nextInt();
        a = new int[n + 1];
        b = new int[n + 1];
        for (int i = 1; i <= n; i++)
            a[i] = nextInt();
        for (int i = 1; i <= n; i++)
            b[i] = nextInt();
        int l = -1, r = 1000000001;
        while (l < r) {
            int mid = (l + r + 1) >> 1;
            if (can(m, mid))
                l = mid;
            else
                r = mid - 1;
        }
        out.println(l);
        out.flush();
    }
 
    static boolean can(int cap, int h) {
        for (int i = 1; i <= n; i++)
            cap -= Math.ceil((double) h / a[i]) * b[i];
        return cap >= 0;
    }
 
    static void swap(int x, int y) {
        int t = nums[x];
        nums[x] = nums[y];
        nums[y] = t;
    }
 
    static int nextInt() {
        try {
            in.nextToken();
        } catch (IOException e) {
            // TODO Auto-generated catch block
            e.printStackTrace();
        }
        return (int) in.nval;
    }
 
    static String next() {
        try {
            in.nextToken();
        } catch (IOException e) {
            // TODO Auto-generated catch block
            e.printStackTrace();
        }
        return in.sval;
    }
 
}
```







##  7.3补充





### +=与-=



**x +=y相当于x=x+y,**
**x -=y相当于x = x-y**





# 8.画画

## 题目描述

初始矩阵(在第1秒)
[a,b]
[c,d]
每一秒一次操作，将当前矩阵向右和右下角复制一份，右下角大小写字母对换。

**输入**

一个数字n,1<=n<=6

**样例输入**

```
2
```

**样例输出** 

```
a b a b 
c d c d 
    A B 
    C D 
```





## 示例代码

```Java
import java.io.BufferedReader;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.OutputStreamWriter;
import java.io.PrintWriter;
import java.io.StreamTokenizer;
import java.util.Arrays;
import java.util.HashMap;
 
public class Main {
    static StreamTokenizer in = new StreamTokenizer(new BufferedReader(new InputStreamReader(System.in)));
    static PrintWriter out = new PrintWriter(new OutputStreamWriter(System.out));
    static int n, m, k, a[], b[], min = Integer.MAX_VALUE, max = Integer.MIN_VALUE, nums[];
 
    public static void main(String[] args) {
        n = nextInt();
        char[] map = new char[256];
        map['a'] = 'A';
        map['b'] = 'B';
        map['c'] = 'C';
        map['d'] = 'D';
        map['A'] = 'a';
        map['B'] = 'b';
        map['C'] = 'c';
        map['D'] = 'd';
        map[' '] = ' ';
        int t = 2;
        char[][] res = new char[1 << 7][1 << 7];
        for (int i = 1; i < 128; i++)
            Arrays.fill(res[i], ' ');
        res[1][1] = 'a';
        res[1][2] = 'b';
        res[2][1] = 'c';
        res[2][2] = 'd';
        dfs(1, 2, res, map);
        n = 1 << n;
        for (int i = 1; i <= n; i++) {
            for (int j = 1; j <= n; j++)
                out.print(res[i][j] + (j == n ? "" : " "));
            out.println();
        }
        out.flush();
    }
 
    static void dfs(int x, int len, char[][] res, char[] map) {
        if (x == 6)
            return;
 
        for (int i = 1; i <= len; i++)
            for (int j = 1; j <= len; j++) {
                res[i][j + len] = res[i][j];
                res[i + len][j + len] = map[res[i][j]];
            }
 
        dfs(x + 1, len * 2, res, map);
    }
 
    static void swap(int x, int y) {
        int t = nums[x];
        nums[x] = nums[y];
        nums[y] = t;
    }
 
    static int nextInt() {
        try {
            in.nextToken();
        } catch (IOException e) {
            // TODO Auto-generated catch block
            e.printStackTrace();
        }
        return (int) in.nval;
    }
 
    static String next() {
        try {
            in.nextToken();
        } catch (IOException e) {
            // TODO Auto-generated catch bck
            e.printStackTrace();
        }
        return in.sval;
    }
 
}
```

# 9.

```java
import java.io.*;
import java.util.*;
 
public class Main {
    static StreamTokenizer in = new StreamTokenizer(new BufferedReader(new InputStreamReader(System.in)));
    static PrintWriter out = new PrintWriter(new OutputStreamWriter(System.out));
    static double dmin = Long.MAX_VALUE;
    static int[][] res;
 
    public static void main(String[] args) {
        int n = nextInt();
        res = new int[1 << 10 + 1][1 << 10 + 1];
        res[1][1] = 1;
        dfs(0);
        for (int i = 1, len = 1 << n; i <= len; i++) {
            for (int j = 1, jl = 1 << n; j <= jl; j++)
                out.print(res[i][j]+(j==jl?"":" "));
            out.println();
        }
        out.flush();
    }
 
    static void dfs(int x) {
        if (x == 10)
            return;
        int now = 1 << x;
        for (int i = 1; i <= now; i++)
            for (int j = 1; j <= now; j++) {
                res[i + now][j + now] = res[i][j];
                res[i + now][j] = res[i][j + now] = res[i][j] + now;
            }
        dfs(x + 1);
    }
 
    static int nextInt() {
        try {
            in.nextToken();
        } catch (IOException e) {
            // TODO Auto-generated catch block
            e.printStackTrace();
        }
        return (int) in.nval;
    }
}
```

# 10.

```java
import java.io.*;
import java.util.*;
 
public class Main {
    static StreamTokenizer in = new StreamTokenizer(new BufferedReader(
            new InputStreamReader(System.in)));
    static PrintWriter out = new PrintWriter(new OutputStreamWriter(System.out));
    static Node[] nodes;
    static double dmin = Long.MAX_VALUE;
 
    public static void main(String[] args) {
        int n = nextInt();
        nodes = new Node[n + 1];
        for (int i = 1; i <= n; i++)
            nodes[i] = new Node(nextInt(), nextInt());
        Arrays.sort(nodes, 1, 1 + n, new Comparator<Node>() {
 
            @Override
            public int compare(Node o1, Node o2) {
                // TODO Auto-generated method stub
                return o1.x - o2.x > 0 ? 1 : -1;
            }
 
        });
        recurtion(1, n);
        System.out.printf("%.10f",dmin);
    }
 
    static void recurtion(int l, int r) {
        if (r <= l)
            return;
        if (r - l == 1) {
            dmin = Math.min(dmin, dis(l, r));
            return;
        }
        int mid = (l + r) >> 1;
        recurtion(l, mid);
        recurtion(mid + 1, r);
        int left = bin_l(nodes[mid].x - (long) dmin - 1,l,r), right = bin_r(nodes[mid].x + (long) dmin + 1,l,r);
        allpd(left, right);
 
    }
     
    static int bin_l(long x,int l,int r){
        while(l<r){
            int mid = (l + r + 1) >> 1;
        if(nodes[mid].x >= x) r = mid - 1;
        else l = mid;
        }
        return l;
    }
     
    static int bin_r(long x,int l,int r){
        while(l<r){
            int mid = (l + r)>>1;
        if(nodes[mid].x <= x) l = mid + 1;
        else r = mid;
        }
        return l;
    }
 
    static int nextInt() {
        try {
            in.nextToken();
        } catch (IOException e) {
            // TODO Auto-generated catch block
            e.printStackTrace();
        }
        return (int) in.nval;
    }
 
    static void allpd(int l, int r) {
        for (int i = l<=0?1:l; i <= r; i++)
            for (int j = i + 1; j <= r; j++) {
                dmin = Math.min(dmin, dis(i, j));
            }
    }
 
    static final double dis(int x, int y) {
        Node ny = nodes[y], nx = nodes[x];
        return Math.sqrt((ny.y - nx.y) * (ny.y - nx.y) + (ny.x - nx.x)
                * (ny.x - nx.x));
    }
}
 
class Node {
    long x, y;
 
    public Node(long x, long y) {
        super();
        this.x = x;
        this.y = y;
    }
 
}
```

